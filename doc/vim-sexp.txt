Symbolic Expressions plugin                                     *vim-sexp.txt*

            o8o
            '"'
oooo    ooooooo ooo. .oo.  .oo.        .oooo.o  .ooooo. oooo    ooooo.ooooo.
 `88.  .8' `888 `888P"Y88bP"Y88b      d88(  "8 d88' `88b `88b..8P'  888' `88b
  `88..8'   888  888   888   888 8888 `"Y88b.  888ooo888   Y888'    888   888
   `888'    888  888   888   888      o.  )88b 888    .o .o8"'88b   888   888
    `8'    o888oo888o o888o o888o     8""888P' `Y8bod8P'o88'   888o 888bod8P'
                                                                    888
                                                                   o888o

==============================================================================
I. INTRODUCTION                                        *vim-sexp-introduction*

Symbolic Expressions are the simplest way to express recursive tree-like
structures with text, and give Lisps their distinctive look and feel. Emacs
users know that what appear to be a preponderance of brackets are really hooks
the editor may use to effortlessly transform the text before them.

Vim, possessing |text-objects|, |cursor-motions|, and an |operator-pending|
mode, is well suited for editing structured text. This plugin extends these
ideas to S-Expressions as embodied by both classical Lisps like Scheme and new
Lisps like Clojure.

A handful of features found in the popular S-Expression plugin for emacs,
paredit.el, are also provided.

==============================================================================
II. MAPPINGS                                               *vim-sexp-mappings*

This is the list of mappings provided by vim-sexp grouped by type. The default
mapping is shown on the left and the full <Plug> name on the right.

Note that all actions that result in visual selections will always be
|characterwise|, regardless of the current visual state.

If vim-repeat [1] is installed, repeating the last change with the |.| command
will work as expected, even for changes made with operator-pending commands.

[1]: http://www.vim.org/scripts/script.php?script_id=2136

TEXT OBJECTS~

af                                                    *sexp_select_list_outer*
if                                                    *sexp_select_list_inner*
        Select [count] lists (compound FORMS) delimited by any of '(' and ')',
        '[' and ']', or '{' and '}'. Outer motion includes the delimiting
        brackets and the inner motion excludes them.

        Does not include surrounding whitespace.

aF                                                *sexp_select_top_list_outer*
iF                                                *sexp_select_top_list_inner*
        Select the current top-level list (compound FORM) delimited by any of
        '(' and ')', '[' and ']', or '{' or '}'. Outer motion includes the
        delimiting brackets and the inner motion excludes them.

        Does not include surrounding whitespace.

        If |g:sexp_maxlines| is -1 (the default), the top-level list is
        determined to be the first parent list with a opening bracket
        on the first column. This is typically much faster than calling
        |searchpairpos()| recursively.

as                                                  *sexp_select_string_outer*
is                                                  *sexp_select_string_inner*
        Select the current string or regular expression. Outer motion includes
        surrounding quotes, inner motion excludes them.

        Does not include surrounding whitespace.

        The default mappings shadow the internal |as| and |is| mappings. These
        sentence text-objects are of limited use in code buffers, but if this
        conflict bothers you, see |g:sexp_mappings| for documentation on
        changing the default mappings.

ae                                                 *sexp_select_element_outer*
ie                                                 *sexp_select_element_inner*
        Select the current element. An element is defined as:

            * Current string if cursor is in a string
            * Current comment if cursor is in a comment, or in the whitespace
              between two line comments
            * Current compound form if cursor is on a paired bracket
            * Current sequence of leading macro characters and following
              element if cursor is on a macro character
            * Current atom otherwise

        An element always includes leading macro characters.

        Inner motion does not include surrounding whitespace, but the outer
        motion includes (ordered by priority):

            * Trailing whitespace up to the next element if next element is on
              the same line
            * Trailing whitespace up to the next element on a subsequent line
              if the current element begins on its own line
            * Trailing whitespace up to the end of line if the current element
              is preceded by another element on the same line
            * Leading whitespace up to the previous element if it exists on
              the same line as the current element and no trailing whitespace
              exists

        If the cursor is on whitespace that is not in a string or between line
        comments, the next element in the buffer is selected.

CURSOR MOTIONS~

(                                                  *sexp_move_to_prev_bracket*
)                                                  *sexp_move_to_next_bracket*
        [count] paired brackets backward or forward, |exclusive|.

        When used in |operator-pending| mode, the following exceptions apply:

            * Backward motion excludes the foremost bracket
            * Forward motion from a bracket excludes both the current bracket
              and the last bracket, unless the resulting selection is empty,
              in which case the motion includes both brackets

        The default mappings shadow the internal |(| and |)| mappings. These
        sentence cursor motions are of limited use in code buffers, but if
        this conflict bothers you, see |g:sexp_mappings| for documentation on
        changing the default mappings.

<M-b>                                         *sexp_move_to_prev_element_head*
<M-w>                                         *sexp_move_to_next_element_head*
        [count] elements backward or forward, |exclusive|, placing the cursor
        on the head of an element. If an element is at the beginning or end of
        a compound form, the cursor is moved to that list's bracket.

        Analogous to |b| and |w| motions.

<M-S-b>                                       *sexp_move_to_prev_element_tail*
<M-e>                                         *sexp_move_to_next_element_tail*
        [count] elements backward or forward, |inclusive|, placing the cursor
        on the tail of an element. If an element is at the beginning or end of
        a compound form, the cursor is moved to that list's bracket.

        Analogous to |ge| and |e| motions.

[[                                             *sexp_move_to_prev_top_element*
]]                                             *sexp_move_to_next_top_element*
        [count] top-level elements backward or forward, |exclusive|.

        If |g:sexp_maxlines| is -1 (the default) and the current element is
        in a list, the top-level element is determined to be the first parent
        list with a opening bracket on the first column. This is typically
        much faster than calling |searchpairpos()| recursively.

[e                                                  *sexp_select_prev_element*
]e                                                  *sexp_select_next_element*
        Select [count]th element from the current element. Unlike the others,
        these motions always result in a visual selection of a single element,
        even when called from visual mode (typically the current selection is
        extended).

        This motion is particularly useful in |operator-pending| mode. For
        instance, in an (if pred then else) form with the cursor on "pred",
        c]e will delete and insert at the "then" form, while c2]e will delete
        and insert at the "else" form.

WRAPPING AND CURSOR INSERTION~

<LocalLeader>i                                     *sexp_list_wrap_round_head*
<LocalLeader>I                                     *sexp_list_wrap_round_tail*
<LocalLeader>[                                    *sexp_list_wrap_square_head*
<LocalLeader>]                                    *sexp_list_wrap_square_tail*
<LocalLeader>{                                     *sexp_list_wrap_curly_head*
<LocalLeader>}                                     *sexp_list_wrap_curly_tail*
        Wrap the current list (compound FORM) or visual selection with '(' and
        ')', '[' and ']', or '{' and '}' and place the cursor at the head or
        tail of the newly created list.

        If |g:sexp_insert_after_wrap| is set (true by default), insert mode is
        entered. Additionally, if the cursor is to be set at the head of the
        list, a space is conditionally appended after the opening bracket so
        that any typed characters will be separated from the next element.

<LocalLeader>W                                  *sexp_element_wrap_round_head*
<LocalLeader>w                                  *sexp_element_wrap_round_tail*
<LocalLeader>e[                                *sexp_element_wrap_square_head*
<LocalLeader>e]                                *sexp_element_wrap_square_tail*
<LocalLeader>e{                                 *sexp_element_wrap_curly_head*
<LocalLeader>e}                                 *sexp_element_wrap_curly_tail*
        Wrap the current element or visual selection with '(' and ')', '[' and
        ']', or '{' and '}' and place the cursor at the head or tail of the
        newly created list.

        If |g:sexp_insert_after_wrap| is set (true by default), insert mode is
        entered. Additionally, if the cursor is to be set at the head of the
        list, a space is conditionally appended after the opening bracket so
        that any typed characters will be separated from the next element.

<LocalLeader>h                                      *sexp_insert_at_list_head*
<LocalLeader>l                                      *sexp_insert_at_list_tail*
        Move cursor to head or tail of current list (compound FORM) and enter
        insert mode.

        If inserting at the head, a space is conditionally appended after the
        opening bracket so that any typed characters will be separated from
        the next element.

S-EXPRESSION MANIPULATION~

<LocalLeader>o                                                *sexp_lift_list*
        Select the current list (compound FORM) or visual selection and
        replace [count] enclosing lists with the selection.

<LocalLeader>O                                              *sexp_splice_list*
        Splice the current list (compound FORM) into its parent scope [count]
        times by deleting the list's brackets.

<M-k>                                                *sexp_swap_list_backward*
<M-j>                                                 *sexp_swap_list_forward*
<M-h>                                             *sexp_swap_element_backward*
<M-l>                                              *sexp_swap_element_forward*
        Swap the current list (compound FORM), element, or visual selection
        [count] times with the adjacent list or element. Does nothing if there
        is no adjacent element in the desired direction.

        If moving a visual selection, the selection is first expanded to cover
        all partially selected lists and elements so that structural integrity
        is maintained.

        If moving an even number of elements with a visual selection, the
        swap is done pairwise to preserve the associative structure of the
        containing compound form.

<M-S-j>                                              *sexp_emit_first_element*
<M-S-k>                                               *sexp_emit_last_element*
<M-S-h>                                            *sexp_capture_prev_element*
<M-S-l>                                            *sexp_capture_next_element*
        Emit [count] terminal elements of the current list, or capture [count]
        elements adjacent to the current list. A list will never emit its last
        element and will never capture its parent.

        These commands are similar to "barfage" and "slurpage" in paredit.el.

 vim:tw=78:et:sw=8:sts=8:ts=8:ft=help:norl:
